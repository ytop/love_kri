[
  {
    "schema_name": "public",
    "function_name": "archive_metadata_changes",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.archive_metadata_changes()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- When updating metadata, archive the old version\n  IF TG_OP = 'UPDATE' THEN\n    -- Set the effective_to date for the old version\n    UPDATE metadata_history \n    SET effective_to = NOW()\n    WHERE metadata_id = OLD.metadata_id \n      AND effective_to IS NULL;\n    \n    -- Insert the new version\n    INSERT INTO metadata_history (\n      metadata_id, kri_code, name, description, formula, owner, data_provider,\n      l1_risk_type, l2_risk_type, ras_metric, breach_type, limit_value, \n      warning_line_value, negative_warning, negative_limit, reporting_frequency,\n      is_calculated_kri, effective_from, effective_to, changed_by, changed_at, change_reason\n    ) VALUES (\n      NEW.metadata_id, NEW.kri_code, NEW.name, NEW.description, NEW.formula, \n      NEW.owner, NEW.data_provider, NEW.l1_risk_type, NEW.l2_risk_type, \n      NEW.ras_metric, NEW.breach_type, NEW.limit_value, NEW.warning_line_value,\n      NEW.negative_warning, NEW.negative_limit, NEW.reporting_frequency,\n      NEW.is_calculated_kri, OLD.updated_at, NULL, 'system', NOW(), 'Metadata updated'\n    );\n    \n    RETURN NEW;\n  END IF;\n  \n  -- When inserting new metadata, create initial history record\n  IF TG_OP = 'INSERT' THEN\n    INSERT INTO metadata_history (\n      metadata_id, kri_code, name, description, formula, owner, data_provider,\n      l1_risk_type, l2_risk_type, ras_metric, breach_type, limit_value, \n      warning_line_value, negative_warning, negative_limit, reporting_frequency,\n      is_calculated_kri, effective_from, effective_to, changed_by, changed_at, change_reason\n    ) VALUES (\n      NEW.metadata_id, NEW.kri_code, NEW.name, NEW.description, NEW.formula, \n      NEW.owner, NEW.data_provider, NEW.l1_risk_type, NEW.l2_risk_type, \n      NEW.ras_metric, NEW.breach_type, NEW.limit_value, NEW.warning_line_value,\n      NEW.negative_warning, NEW.negative_limit, NEW.reporting_frequency,\n      NEW.is_calculated_kri, NEW.created_at, NULL, 'system', NOW(), 'Initial metadata creation'\n    );\n    \n    RETURN NEW;\n  END IF;\n  \n  RETURN NULL;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_current_kri_metadata",
    "arguments": "p_kri_code text",
    "return_type": "TABLE(metadata_id bigint, kri_code text, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean, created_at timestamp with time zone, updated_at timestamp with time zone)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_current_kri_metadata(p_kri_code text)\n RETURNS TABLE(metadata_id bigint, kri_code text, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT * FROM get_kri_metadata_at_time(p_kri_code, NOW());\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_kri_config_at_time",
    "arguments": "p_kri_code text, p_effective_time timestamp with time zone",
    "return_type": "TABLE(metadata_id bigint, kri_code text, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_kri_config_at_time(p_kri_code text, p_effective_time timestamp with time zone)\n RETURNS TABLE(metadata_id bigint, kri_code text, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    h.metadata_id,\n    h.kri_code,\n    h.name,\n    h.description,\n    h.formula,\n    h.owner,\n    h.data_provider,\n    h.l1_risk_type,\n    h.l2_risk_type,\n    h.ras_metric,\n    h.breach_type,\n    h.limit_value,\n    h.warning_line_value,\n    h.negative_warning,          -- New field\n    h.negative_limit,            -- New field\n    h.reporting_frequency,\n    h.is_calculated_kri\n  FROM metadata_history h\n  WHERE h.kri_code = p_kri_code\n    AND h.effective_from <= p_effective_time\n    AND (h.effective_to > p_effective_time OR h.effective_to IS NULL)\n  ORDER BY h.effective_from DESC\n  LIMIT 1;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_kri_metadata_at_time",
    "arguments": "p_kri_code text, p_effective_time timestamp with time zone DEFAULT now()",
    "return_type": "TABLE(metadata_id bigint, kri_code text, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean, created_at timestamp with time zone, updated_at timestamp with time zone)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_kri_metadata_at_time(p_kri_code text, p_effective_time timestamp with time zone DEFAULT now())\n RETURNS TABLE(metadata_id bigint, kri_code text, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        km.metadata_id,\n        km.kri_code,\n        km.name,\n        km.description,\n        km.formula,\n        km.owner,\n        km.data_provider,\n        km.l1_risk_type,\n        km.l2_risk_type,\n        km.ras_metric,\n        km.limit_value,\n        km.warning_line_value,\n        km.negative_warning,\n        km.negative_limit,\n        km.reporting_frequency,\n        km.is_calculated_kri,\n        km.created_at,\n        km.updated_at\n    FROM public.kri_metadata km\n    WHERE km.kri_code = p_kri_code\n      AND km.created_at <= p_effective_time\n    ORDER BY km.created_at DESC\n    LIMIT 1;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_kri_with_metadata",
    "arguments": "p_kri_id bigint DEFAULT NULL::bigint, p_reporting_date integer DEFAULT NULL::integer, p_kri_code text DEFAULT NULL::text",
    "return_type": "TABLE(kri_id bigint, reporting_date integer, kri_code text, metadata_effective_date timestamp with time zone, kri_value text, kri_status integer, breach_type text, source text, evidence_id bigint, created_at timestamp with time zone, kri_name text, kri_description text, kri_formula text, kri_owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_kri_with_metadata(p_kri_id bigint DEFAULT NULL::bigint, p_reporting_date integer DEFAULT NULL::integer, p_kri_code text DEFAULT NULL::text)\n RETURNS TABLE(kri_id bigint, reporting_date integer, kri_code text, metadata_effective_date timestamp with time zone, kri_value text, kri_status integer, breach_type text, source text, evidence_id bigint, created_at timestamp with time zone, kri_name text, kri_description text, kri_formula text, kri_owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        ki.kri_id,\n        ki.reporting_date,\n        ki.kri_code,\n        ki.metadata_effective_date,\n        ki.kri_value,\n        ki.kri_status,\n        ki.breach_type,  -- Now from kri_item table\n        ki.source,\n        ki.evidence_id,\n        ki.created_at,\n        m.name as kri_name,\n        m.description as kri_description,\n        m.formula as kri_formula,\n        m.owner as kri_owner,\n        m.data_provider,\n        m.l1_risk_type,\n        m.l2_risk_type,\n        m.ras_metric,\n        m.limit_value,\n        m.warning_line_value,\n        m.negative_warning,\n        m.negative_limit,\n        m.reporting_frequency,\n        m.is_calculated_kri\n    FROM public.kri_item ki\n    CROSS JOIN LATERAL (\n        SELECT\n            get_kri_metadata_at_time.metadata_id,\n            get_kri_metadata_at_time.kri_code,\n            get_kri_metadata_at_time.name,\n            get_kri_metadata_at_time.description,\n            get_kri_metadata_at_time.formula,\n            get_kri_metadata_at_time.owner,\n            get_kri_metadata_at_time.data_provider,\n            get_kri_metadata_at_time.l1_risk_type,\n            get_kri_metadata_at_time.l2_risk_type,\n            get_kri_metadata_at_time.ras_metric,\n            get_kri_metadata_at_time.limit_value,\n            get_kri_metadata_at_time.warning_line_value,\n            get_kri_metadata_at_time.negative_warning,\n            get_kri_metadata_at_time.negative_limit,\n            get_kri_metadata_at_time.reporting_frequency,\n            get_kri_metadata_at_time.is_calculated_kri,\n            get_kri_metadata_at_time.created_at,\n            get_kri_metadata_at_time.updated_at\n        FROM\n            get_kri_metadata_at_time(\n                ki.kri_code,\n                COALESCE(ki.metadata_effective_date, now())\n            ) get_kri_metadata_at_time(\n                metadata_id,\n                kri_code,\n                name,\n                description,\n                formula,\n                owner,\n                data_provider,\n                l1_risk_type,\n                l2_risk_type,\n                ras_metric,\n                limit_value,\n                warning_line_value,\n                negative_warning,\n                negative_limit,\n                reporting_frequency,\n                is_calculated_kri,\n                created_at,\n                updated_at\n            )\n    ) m\n    WHERE (p_kri_id IS NULL OR ki.kri_id = p_kri_id)\n      AND (p_reporting_date IS NULL OR ki.reporting_date = p_reporting_date)\n      AND (p_kri_code IS NULL OR ki.kri_code = p_kri_code);\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_kris_for_date",
    "arguments": "p_reporting_date integer",
    "return_type": "TABLE(kri_id bigint, reporting_date integer, kri_code text, kri_value text, kri_status integer, source text, evidence_id bigint, created_at timestamp with time zone, kri_name text, kri_description text, kri_formula text, kri_owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_kris_for_date(p_reporting_date integer)\n RETURNS TABLE(kri_id bigint, reporting_date integer, kri_code text, kri_value text, kri_status integer, source text, evidence_id bigint, created_at timestamp with time zone, kri_name text, kri_description text, kri_formula text, kri_owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT * FROM kri_with_metadata kwm\n  WHERE kwm.reporting_date = p_reporting_date\n  ORDER BY kwm.kri_id;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "set_metadata_effective_date",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_metadata_effective_date()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- If metadata_effective_date is not provided, set it to the current timestamp\n  IF NEW.metadata_effective_date IS NULL THEN\n    NEW.metadata_effective_date := NOW();\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_kri_status_from_atomic",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_kri_status_from_atomic()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  all_atomic_finalized boolean;\n  kri_metadata_rec RECORD;\nBEGIN\n  -- Get metadata to check if this is a calculated KRI\n  SELECT * INTO kri_metadata_rec \n  FROM get_current_kri_metadata(\n    (SELECT kri_code FROM kri_item WHERE kri_id = NEW.kri_id AND reporting_date = NEW.reporting_date)\n  );\n  \n  -- Only proceed if this is a calculated KRI\n  IF kri_metadata_rec.is_calculated_kri THEN\n    -- Check if all atomic components for this KRI are finalized (status 60)\n    SELECT NOT EXISTS (\n      SELECT 1 FROM kri_atomic ka\n      WHERE ka.kri_id = NEW.kri_id \n        AND ka.reporting_date = NEW.reporting_date\n        AND (ka.atomic_status IS NULL OR ka.atomic_status != 60)\n    ) INTO all_atomic_finalized;\n    \n    -- If all atomics are finalized, update KRI status to finalized\n    IF all_atomic_finalized THEN\n      UPDATE kri_item \n      SET kri_status = 60 \n      WHERE kri_id = NEW.kri_id AND reporting_date = NEW.reporting_date;\n      \n      -- Add audit trail entry\n      INSERT INTO kri_audit_trail (\n        kri_id, reporting_date, changed_at, changed_by, action, \n        field_name, old_value, new_value, comment, kri_code\n      ) VALUES (\n        NEW.kri_id, NEW.reporting_date, NOW(), 'system', 'auto_finalize_from_atomic',\n        'kri_status', \n        (SELECT kri_status FROM kri_item WHERE kri_id = NEW.kri_id AND reporting_date = NEW.reporting_date),\n        '60',\n        'KRI automatically finalized as all atomic components are finalized',\n        (SELECT kri_code FROM kri_item WHERE kri_id = NEW.kri_id AND reporting_date = NEW.reporting_date)\n      );\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "updateatomickri",
    "arguments": "p_kri_id bigint, p_atomic_id integer, p_reporting_date integer, p_update_data jsonb, p_changed_by text DEFAULT NULL::text, p_action text DEFAULT 'update'::text, p_comment text DEFAULT NULL::text",
    "return_type": "TABLE(kri_id bigint, atomic_id integer, reporting_date integer, atomic_metadata text, atomic_value text, atomic_status integer, created_at timestamp with time zone, source text, kri_code text, evidence_id bigint)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.updateatomickri(p_kri_id bigint, p_atomic_id integer, p_reporting_date integer, p_update_data jsonb, p_changed_by text DEFAULT NULL::text, p_action text DEFAULT 'update'::text, p_comment text DEFAULT NULL::text)\n RETURNS TABLE(kri_id bigint, atomic_id integer, reporting_date integer, atomic_metadata text, atomic_value text, atomic_status integer, created_at timestamp with time zone, source text, kri_code text, evidence_id bigint)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    old_record record;\n    updated_record record;\nBEGIN\n    -- Get the current record for audit trail\n    SELECT * INTO old_record \n    FROM kri_atomic \n    WHERE kri_atomic.kri_id = p_kri_id \n      AND kri_atomic.atomic_id = p_atomic_id \n      AND kri_atomic.reporting_date = p_reporting_date;\n    \n    -- Update the atomic record\n    UPDATE kri_atomic \n    SET \n        atomic_metadata = COALESCE((p_update_data->>'atomic_metadata')::text, kri_atomic.atomic_metadata),\n        atomic_value = COALESCE((p_update_data->>'atomic_value')::text, kri_atomic.atomic_value),\n        atomic_status = COALESCE((p_update_data->>'atomic_status')::integer, kri_atomic.atomic_status),\n        source = COALESCE((p_update_data->>'source')::text, kri_atomic.source),\n        evidence_id = COALESCE((p_update_data->>'evidence_id')::bigint, kri_atomic.evidence_id)\n    WHERE kri_atomic.kri_id = p_kri_id \n      AND kri_atomic.atomic_id = p_atomic_id \n      AND kri_atomic.reporting_date = p_reporting_date\n    RETURNING * INTO updated_record;\n    \n    -- Insert audit trail record with correct column names (old_value/new_value, not old_values/new_values)\n    INSERT INTO kri_audit_trail (\n        kri_id,\n        reporting_date,\n        changed_by,\n        action,\n        old_value,\n        new_value,\n        comment,\n        kri_code\n    ) VALUES (\n        p_kri_id,\n        p_reporting_date,\n        COALESCE(p_changed_by, 'system'),\n        p_action,\n        to_jsonb(old_record)::text,\n        to_jsonb(updated_record)::text,\n        p_comment,\n        old_record.kri_code\n    );\n    \n    -- Return the updated record\n    RETURN QUERY \n    SELECT \n        updated_record.kri_id,\n        updated_record.atomic_id,\n        updated_record.reporting_date,\n        updated_record.atomic_metadata,\n        updated_record.atomic_value,\n        updated_record.atomic_status,\n        updated_record.created_at,\n        updated_record.source,\n        updated_record.kri_code,\n        updated_record.evidence_id;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "updateevidence",
    "arguments": "p_evidence_id bigint, p_update_data jsonb, p_changed_by text, p_action text, p_comment text",
    "return_type": "TABLE(evidence_id bigint, kri_id bigint, reporting_date integer, file_name text, file_url text, description text, uploaded_by text, uploaded_at timestamp with time zone)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.updateevidence(p_evidence_id bigint, p_update_data jsonb, p_changed_by text, p_action text, p_comment text)\n RETURNS TABLE(evidence_id bigint, kri_id bigint, reporting_date integer, file_name text, file_url text, description text, uploaded_by text, uploaded_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  old_row kri_evidence%ROWTYPE;\n  new_row kri_evidence%ROWTYPE;\n  key text;\n  new_val text;\n  old_val text;\n  update_stmt text;\n  set_clauses text = '';\n  first boolean = true;\nBEGIN\n  -- Lock and fetch the old row\n  SELECT * INTO old_row FROM kri_evidence WHERE evidence_id = p_evidence_id FOR UPDATE;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Evidence record not found for update (evidence_id=%)', p_evidence_id;\n  END IF;\n\n  -- Build dynamic SET clause for update\n  FOR key, new_val IN SELECT key, value FROM jsonb_each_text(p_update_data) LOOP\n    IF NOT first THEN\n      set_clauses := set_clauses || ', ';\n    END IF;\n    set_clauses := set_clauses || format('%I = %L', key, new_val);\n    first := false;\n  END LOOP;\n\n  update_stmt := format(\n    'UPDATE kri_evidence SET %s WHERE evidence_id = $1 RETURNING *',\n    set_clauses\n  );\n\n  -- Perform the update and fetch the new row\n  EXECUTE update_stmt INTO new_row USING p_evidence_id;\n\n  -- For each updated field, insert audit trail entry\n  FOR key, new_val IN SELECT key, value FROM jsonb_each_text(p_update_data) LOOP\n    EXECUTE format('SELECT ($1).%I::text', key) INTO old_val USING old_row;\n    INSERT INTO kri_audit_trail (\n      kri_id, reporting_date, changed_at, changed_by, action, field_name, old_value, new_value, comment\n    ) VALUES (\n      old_row.kri_id,\n      old_row.reporting_date,\n      NOW(),\n      p_changed_by,\n      p_action,\n      key,\n      old_val,\n      new_val,\n      p_comment\n    );\n  END LOOP;\n\n  -- Return the updated row\n  RETURN QUERY\n    SELECT\n      new_row.evidence_id,\n      new_row.kri_id,\n      new_row.reporting_date,\n      new_row.file_name,\n      new_row.file_url,\n      new_row.description,\n      new_row.uploaded_by,\n      new_row.uploaded_at;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "updatekri",
    "arguments": "p_kri_id bigint, p_reporting_date integer, p_update_data jsonb, p_changed_by text, p_action text, p_comment text",
    "return_type": "TABLE(kri_id bigint, reporting_date integer, kri_code text, kri_value text, kri_status integer, breach_type text, source text, evidence_id bigint, created_at timestamp with time zone, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.updatekri(p_kri_id bigint, p_reporting_date integer, p_update_data jsonb, p_changed_by text, p_action text, p_comment text)\n RETURNS TABLE(kri_id bigint, reporting_date integer, kri_code text, kri_value text, kri_status integer, breach_type text, source text, evidence_id bigint, created_at timestamp with time zone, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  old_row kri_item%ROWTYPE;\n  new_row kri_item%ROWTYPE;\n  field_key text;\n  field_val text;\n  old_field_val text;\n  update_stmt text;\n  set_clauses text = '';\n  first boolean = true;\n  metadata_rec RECORD;\nBEGIN\n  -- Lock and fetch the old row\n  SELECT * INTO old_row FROM kri_item ki WHERE ki.kri_id = p_kri_id AND ki.reporting_date = p_reporting_date FOR UPDATE;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'KRI record not found for update (kri_id=%, reporting_date=%)', p_kri_id, p_reporting_date;\n  END IF;\n\n  -- Build dynamic SET clause for update\n  FOR field_key, field_val IN SELECT key, value FROM jsonb_each_text(p_update_data) LOOP\n    IF NOT first THEN\n      set_clauses := set_clauses || ', ';\n    END IF;\n    set_clauses := set_clauses || format('%I = %L', field_key, field_val);\n    first := false;\n  END LOOP;\n\n  update_stmt := format(\n    'UPDATE kri_item SET %s WHERE kri_item.kri_id = $1 AND kri_item.reporting_date = $2 RETURNING *',\n    set_clauses\n  );\n\n  -- Perform the update and fetch the new row\n  EXECUTE update_stmt INTO new_row USING p_kri_id, p_reporting_date;\n\n  -- For each updated field, insert audit trail entry\n  FOR field_key, field_val IN SELECT key, value FROM jsonb_each_text(p_update_data) LOOP\n    EXECUTE format('SELECT ($1).%I::text', field_key) INTO old_field_val USING old_row;\n    INSERT INTO kri_audit_trail (\n      kri_id, reporting_date, changed_at, changed_by, action, field_name, old_value, new_value, comment, kri_code\n    ) VALUES (\n      p_kri_id,\n      p_reporting_date,\n      NOW(),\n      p_changed_by,\n      p_action,\n      field_key,\n      old_field_val,\n      field_val,\n      p_comment,\n      new_row.kri_code\n    );\n  END LOOP;\n\n  -- Get metadata using the effective date or current if not set\n  SELECT * INTO metadata_rec \n  FROM get_kri_metadata_at_time(\n    new_row.kri_code, \n    COALESCE(new_row.metadata_effective_date, NOW())\n  );\n\n  -- Return the updated row with metadata (breach_type from kri_item, not metadata)\n  RETURN QUERY\n    SELECT\n      new_row.kri_id,\n      new_row.reporting_date,\n      new_row.kri_code,\n      new_row.kri_value,\n      new_row.kri_status,\n      new_row.breach_type,  -- From kri_item table\n      new_row.source,\n      new_row.evidence_id,\n      new_row.created_at,\n      metadata_rec.name,\n      metadata_rec.description,\n      metadata_rec.formula,\n      metadata_rec.owner,\n      metadata_rec.data_provider,\n      metadata_rec.l1_risk_type,\n      metadata_rec.l2_risk_type,\n      metadata_rec.ras_metric,\n      metadata_rec.limit_value,\n      metadata_rec.warning_line_value,\n      metadata_rec.negative_warning,\n      metadata_rec.negative_limit,\n      metadata_rec.reporting_frequency,\n      metadata_rec.is_calculated_kri;\nEND;\n$function$\n"
  }
]