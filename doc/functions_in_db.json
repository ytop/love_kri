[
  {
    "schema_name": "public",
    "function_name": "archive_metadata_changes",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.archive_metadata_changes()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- When updating metadata, archive the old version\n  IF TG_OP = 'UPDATE' THEN\n    -- Set the effective_to date for the old version\n    UPDATE metadata_history \n    SET effective_to = NOW()\n    WHERE metadata_id = OLD.metadata_id \n      AND effective_to IS NULL;\n    \n    -- Insert the new version\n    INSERT INTO metadata_history (\n      metadata_id, kri_code, name, description, formula, owner, data_provider,\n      l1_risk_type, l2_risk_type, ras_metric, breach_type, limit_value, \n      warning_line_value, negative_warning, negative_limit, reporting_frequency,\n      is_calculated_kri, effective_from, effective_to, changed_by, changed_at, change_reason\n    ) VALUES (\n      NEW.metadata_id, NEW.kri_code, NEW.name, NEW.description, NEW.formula, \n      NEW.owner, NEW.data_provider, NEW.l1_risk_type, NEW.l2_risk_type, \n      NEW.ras_metric, NEW.breach_type, NEW.limit_value, NEW.warning_line_value,\n      NEW.negative_warning, NEW.negative_limit, NEW.reporting_frequency,\n      NEW.is_calculated_kri, OLD.updated_at, NULL, 'system', NOW(), 'Metadata updated'\n    );\n    \n    RETURN NEW;\n  END IF;\n  \n  -- When inserting new metadata, create initial history record\n  IF TG_OP = 'INSERT' THEN\n    INSERT INTO metadata_history (\n      metadata_id, kri_code, name, description, formula, owner, data_provider,\n      l1_risk_type, l2_risk_type, ras_metric, breach_type, limit_value, \n      warning_line_value, negative_warning, negative_limit, reporting_frequency,\n      is_calculated_kri, effective_from, effective_to, changed_by, changed_at, change_reason\n    ) VALUES (\n      NEW.metadata_id, NEW.kri_code, NEW.name, NEW.description, NEW.formula, \n      NEW.owner, NEW.data_provider, NEW.l1_risk_type, NEW.l2_risk_type, \n      NEW.ras_metric, NEW.breach_type, NEW.limit_value, NEW.warning_line_value,\n      NEW.negative_warning, NEW.negative_limit, NEW.reporting_frequency,\n      NEW.is_calculated_kri, NEW.created_at, NULL, 'system', NOW(), 'Initial metadata creation'\n    );\n    \n    RETURN NEW;\n  END IF;\n  \n  RETURN NULL;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_current_kri_metadata",
    "arguments": "p_kri_code text",
    "return_type": "TABLE(metadata_id bigint, kri_code text, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean, created_at timestamp with time zone, updated_at timestamp with time zone)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_current_kri_metadata(p_kri_code text)\n RETURNS TABLE(metadata_id bigint, kri_code text, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT * FROM get_kri_metadata_at_time(p_kri_code, NOW());\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_kri_config_at_time",
    "arguments": "p_kri_code text, p_effective_time timestamp with time zone",
    "return_type": "TABLE(metadata_id bigint, kri_code text, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_kri_config_at_time(p_kri_code text, p_effective_time timestamp with time zone)\n RETURNS TABLE(metadata_id bigint, kri_code text, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    h.metadata_id,\n    h.kri_code,\n    h.name,\n    h.description,\n    h.formula,\n    h.owner,\n    h.data_provider,\n    h.l1_risk_type,\n    h.l2_risk_type,\n    h.ras_metric,\n    h.breach_type,\n    h.limit_value,\n    h.warning_line_value,\n    h.negative_warning,          -- New field\n    h.negative_limit,            -- New field\n    h.reporting_frequency,\n    h.is_calculated_kri\n  FROM metadata_history h\n  WHERE h.kri_code = p_kri_code\n    AND h.effective_from <= p_effective_time\n    AND (h.effective_to > p_effective_time OR h.effective_to IS NULL)\n  ORDER BY h.effective_from DESC\n  LIMIT 1;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_kri_metadata_at_time",
    "arguments": "p_kri_code text, p_effective_date timestamp with time zone DEFAULT now()",
    "return_type": "TABLE(metadata_id bigint, kri_code text, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean, created_at timestamp with time zone, updated_at timestamp with time zone)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_kri_metadata_at_time(p_kri_code text, p_effective_date timestamp with time zone DEFAULT now())\n RETURNS TABLE(metadata_id bigint, kri_code text, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- First try to get from current metadata if it matches the time\n  RETURN QUERY\n  SELECT \n    km.metadata_id,\n    km.kri_code,\n    km.name,\n    km.description,\n    km.formula,\n    km.owner,\n    km.data_provider,\n    km.l1_risk_type,\n    km.l2_risk_type,\n    km.ras_metric,\n    km.breach_type,\n    km.limit_value,\n    km.warning_line_value,\n    km.negative_warning,\n    km.negative_limit,\n    km.reporting_frequency,\n    km.is_calculated_kri,\n    km.created_at,\n    km.updated_at\n  FROM kri_metadata km\n  WHERE km.kri_code = p_kri_code\n    AND km.created_at <= p_effective_date\n    AND (km.updated_at IS NULL OR km.updated_at > p_effective_date);\n    \n  -- If no current metadata matches, get from history\n  IF NOT FOUND THEN\n    RETURN QUERY\n    SELECT \n      mh.metadata_id,\n      mh.kri_code,\n      mh.name,\n      mh.description,\n      mh.formula,\n      mh.owner,\n      mh.data_provider,\n      mh.l1_risk_type,\n      mh.l2_risk_type,\n      mh.ras_metric,\n      mh.breach_type,\n      mh.limit_value,\n      mh.warning_line_value,\n      mh.negative_warning,\n      mh.negative_limit,\n      mh.reporting_frequency,\n      mh.is_calculated_kri,\n      mh.effective_from as created_at,\n      mh.effective_to as updated_at\n    FROM metadata_history mh\n    WHERE mh.kri_code = p_kri_code\n      AND mh.effective_from <= p_effective_date\n      AND (mh.effective_to IS NULL OR mh.effective_to > p_effective_date)\n    ORDER BY mh.effective_from DESC\n    LIMIT 1;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_kri_with_metadata",
    "arguments": "p_kri_id bigint, p_reporting_date integer",
    "return_type": "TABLE(kri_id bigint, reporting_date integer, kri_code text, kri_value text, kri_status integer, source text, evidence_id bigint, created_at timestamp with time zone, kri_name text, kri_description text, kri_formula text, kri_owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_kri_with_metadata(p_kri_id bigint, p_reporting_date integer)\n RETURNS TABLE(kri_id bigint, reporting_date integer, kri_code text, kri_value text, kri_status integer, source text, evidence_id bigint, created_at timestamp with time zone, kri_name text, kri_description text, kri_formula text, kri_owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT * FROM kri_with_metadata kwm\n  WHERE kwm.kri_id = p_kri_id AND kwm.reporting_date = p_reporting_date;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_kris_for_date",
    "arguments": "p_reporting_date integer",
    "return_type": "TABLE(kri_id bigint, reporting_date integer, kri_code text, kri_value text, kri_status integer, source text, evidence_id bigint, created_at timestamp with time zone, kri_name text, kri_description text, kri_formula text, kri_owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_kris_for_date(p_reporting_date integer)\n RETURNS TABLE(kri_id bigint, reporting_date integer, kri_code text, kri_value text, kri_status integer, source text, evidence_id bigint, created_at timestamp with time zone, kri_name text, kri_description text, kri_formula text, kri_owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT * FROM kri_with_metadata kwm\n  WHERE kwm.reporting_date = p_reporting_date\n  ORDER BY kwm.kri_id;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "recalculate_all_kri_statuses_fixed",
    "arguments": "",
    "return_type": "void",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.recalculate_all_kri_statuses_fixed()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Update KRI status to 60 (finalized) for calculated KRIs where all atomics are finalized\n    UPDATE kri_item \n    SET kri_status = 60\n    WHERE kri_id IN (\n        SELECT DISTINCT ki.kri_id\n        FROM kri_item ki\n        CROSS JOIN LATERAL (\n            SELECT is_calculated_kri \n            FROM get_kri_metadata_at_time(ki.kri_code, COALESCE(ki.metadata_effective_date, NOW()))\n        ) m\n        WHERE m.is_calculated_kri = true\n          AND NOT EXISTS (\n              SELECT 1 FROM kri_atomic ka\n              WHERE ka.kri_id = ki.kri_id \n                AND ka.reporting_date = ki.reporting_date\n                AND (ka.atomic_status IS NULL OR ka.atomic_status != 60)\n          )\n          AND ki.kri_status != 60\n    );\n    \n    -- Log the bulk recalculation\n    INSERT INTO kri_audit_trail (\n        kri_id, \n        reporting_date, \n        action, \n        field_name, \n        comment,\n        changed_by,\n        kri_code\n    )\n    SELECT DISTINCT\n        ki.kri_id,\n        ki.reporting_date,\n        'bulk_status_recalc_fixed',\n        'kri_status',\n        'Bulk recalculation of calculated KRI statuses (fixed version)',\n        'SYSTEM',\n        ki.kri_code\n    FROM kri_item ki\n    CROSS JOIN LATERAL (\n        SELECT is_calculated_kri \n        FROM get_kri_metadata_at_time(ki.kri_code, COALESCE(ki.metadata_effective_date, NOW()))\n    ) m\n    WHERE m.is_calculated_kri = true;\n    \n    RAISE NOTICE 'Recalculated statuses for all calculated KRIs using new metadata architecture';\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "set_metadata_effective_date",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_metadata_effective_date()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- If metadata_effective_date is not provided, set it to the current timestamp\n  IF NEW.metadata_effective_date IS NULL THEN\n    NEW.metadata_effective_date := NOW();\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_kri_status_from_atomic",
    "arguments": "",
    "return_type": "trigger",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_kri_status_from_atomic()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  all_atomic_finalized boolean;\n  kri_metadata_rec RECORD;\nBEGIN\n  -- Get metadata to check if this is a calculated KRI\n  SELECT * INTO kri_metadata_rec \n  FROM get_current_kri_metadata(\n    (SELECT kri_code FROM kri_item WHERE kri_id = NEW.kri_id AND reporting_date = NEW.reporting_date)\n  );\n  \n  -- Only proceed if this is a calculated KRI\n  IF kri_metadata_rec.is_calculated_kri THEN\n    -- Check if all atomic components for this KRI are finalized (status 60)\n    SELECT NOT EXISTS (\n      SELECT 1 FROM kri_atomic ka\n      WHERE ka.kri_id = NEW.kri_id \n        AND ka.reporting_date = NEW.reporting_date\n        AND (ka.atomic_status IS NULL OR ka.atomic_status != 60)\n    ) INTO all_atomic_finalized;\n    \n    -- If all atomics are finalized, update KRI status to finalized\n    IF all_atomic_finalized THEN\n      UPDATE kri_item \n      SET kri_status = 60 \n      WHERE kri_id = NEW.kri_id AND reporting_date = NEW.reporting_date;\n      \n      -- Add audit trail entry\n      INSERT INTO kri_audit_trail (\n        kri_id, reporting_date, changed_at, changed_by, action, \n        field_name, old_value, new_value, comment, kri_code\n      ) VALUES (\n        NEW.kri_id, NEW.reporting_date, NOW(), 'system', 'auto_finalize_from_atomic',\n        'kri_status', \n        (SELECT kri_status FROM kri_item WHERE kri_id = NEW.kri_id AND reporting_date = NEW.reporting_date),\n        '60',\n        'KRI automatically finalized as all atomic components are finalized',\n        (SELECT kri_code FROM kri_item WHERE kri_id = NEW.kri_id AND reporting_date = NEW.reporting_date)\n      );\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "updateevidence",
    "arguments": "p_evidence_id bigint, p_update_data jsonb, p_changed_by text, p_action text, p_comment text",
    "return_type": "TABLE(evidence_id bigint, kri_id bigint, reporting_date integer, file_name text, file_url text, description text, uploaded_by text, uploaded_at timestamp with time zone)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.updateevidence(p_evidence_id bigint, p_update_data jsonb, p_changed_by text, p_action text, p_comment text)\n RETURNS TABLE(evidence_id bigint, kri_id bigint, reporting_date integer, file_name text, file_url text, description text, uploaded_by text, uploaded_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  old_row kri_evidence%ROWTYPE;\n  new_row kri_evidence%ROWTYPE;\n  key text;\n  new_val text;\n  old_val text;\n  update_stmt text;\n  set_clauses text = '';\n  first boolean = true;\nBEGIN\n  -- Lock and fetch the old row\n  SELECT * INTO old_row FROM kri_evidence WHERE evidence_id = p_evidence_id FOR UPDATE;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Evidence record not found for update (evidence_id=%)', p_evidence_id;\n  END IF;\n\n  -- Build dynamic SET clause for update\n  FOR key, new_val IN SELECT key, value FROM jsonb_each_text(p_update_data) LOOP\n    IF NOT first THEN\n      set_clauses := set_clauses || ', ';\n    END IF;\n    set_clauses := set_clauses || format('%I = %L', key, new_val);\n    first := false;\n  END LOOP;\n\n  update_stmt := format(\n    'UPDATE kri_evidence SET %s WHERE evidence_id = $1 RETURNING *',\n    set_clauses\n  );\n\n  -- Perform the update and fetch the new row\n  EXECUTE update_stmt INTO new_row USING p_evidence_id;\n\n  -- For each updated field, insert audit trail entry\n  FOR key, new_val IN SELECT key, value FROM jsonb_each_text(p_update_data) LOOP\n    EXECUTE format('SELECT ($1).%I::text', key) INTO old_val USING old_row;\n    INSERT INTO kri_audit_trail (\n      kri_id, reporting_date, changed_at, changed_by, action, field_name, old_value, new_value, comment\n    ) VALUES (\n      old_row.kri_id,\n      old_row.reporting_date,\n      NOW(),\n      p_changed_by,\n      p_action,\n      key,\n      old_val,\n      new_val,\n      p_comment\n    );\n  END LOOP;\n\n  -- Return the updated row\n  RETURN QUERY\n    SELECT\n      new_row.evidence_id,\n      new_row.kri_id,\n      new_row.reporting_date,\n      new_row.file_name,\n      new_row.file_url,\n      new_row.description,\n      new_row.uploaded_by,\n      new_row.uploaded_at;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "updatekri",
    "arguments": "p_kri_id bigint, p_reporting_date integer, p_update_data jsonb, p_changed_by text, p_action text, p_comment text",
    "return_type": "TABLE(kri_id bigint, reporting_date integer, kri_code text, kri_value text, kri_status integer, source text, evidence_id bigint, created_at timestamp with time zone, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)",
    "language": "plpgsql",
    "volatility": "VOLATILE",
    "function_definition": "CREATE OR REPLACE FUNCTION public.updatekri(p_kri_id bigint, p_reporting_date integer, p_update_data jsonb, p_changed_by text, p_action text, p_comment text)\n RETURNS TABLE(kri_id bigint, reporting_date integer, kri_code text, kri_value text, kri_status integer, source text, evidence_id bigint, created_at timestamp with time zone, name text, description text, formula text, owner text, data_provider text, l1_risk_type text, l2_risk_type text, ras_metric text, breach_type text, limit_value integer, warning_line_value integer, negative_warning integer, negative_limit integer, reporting_frequency text, is_calculated_kri boolean)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  old_row kri_item%ROWTYPE;\n  new_row kri_item%ROWTYPE;\n  field_key text;\n  field_val text;\n  old_field_val text;\n  update_stmt text;\n  set_clauses text = '';\n  first boolean = true;\n  metadata_rec RECORD;\nBEGIN\n  -- Lock and fetch the old row\n  SELECT * INTO old_row FROM kri_item ki WHERE ki.kri_id = p_kri_id AND ki.reporting_date = p_reporting_date FOR UPDATE;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'KRI record not found for update (kri_id=%, reporting_date=%)', p_kri_id, p_reporting_date;\n  END IF;\n\n  -- Build dynamic SET clause for update\n  FOR field_key, field_val IN SELECT key, value FROM jsonb_each_text(p_update_data) LOOP\n    IF NOT first THEN\n      set_clauses := set_clauses || ', ';\n    END IF;\n    set_clauses := set_clauses || format('%I = %L', field_key, field_val);\n    first := false;\n  END LOOP;\n\n  update_stmt := format(\n    'UPDATE kri_item SET %s WHERE kri_item.kri_id = $1 AND kri_item.reporting_date = $2 RETURNING *',\n    set_clauses\n  );\n\n  -- Perform the update and fetch the new row\n  EXECUTE update_stmt INTO new_row USING p_kri_id, p_reporting_date;\n\n  -- For each updated field, insert audit trail entry\n  FOR field_key, field_val IN SELECT key, value FROM jsonb_each_text(p_update_data) LOOP\n    EXECUTE format('SELECT ($1).%I::text', field_key) INTO old_field_val USING old_row;\n    INSERT INTO kri_audit_trail (\n      kri_id, reporting_date, changed_at, changed_by, action, field_name, old_value, new_value, comment, kri_code\n    ) VALUES (\n      p_kri_id,\n      p_reporting_date,\n      NOW(),\n      p_changed_by,\n      p_action,\n      field_key,\n      old_field_val,\n      field_val,\n      p_comment,\n      new_row.kri_code\n    );\n  END LOOP;\n\n  -- Get metadata using the effective date or current if not set\n  SELECT * INTO metadata_rec \n  FROM get_kri_metadata_at_time(\n    new_row.kri_code, \n    COALESCE(new_row.metadata_effective_date, NOW())\n  );\n\n  -- Return the updated row with metadata\n  RETURN QUERY\n    SELECT\n      new_row.kri_id,\n      new_row.reporting_date,\n      new_row.kri_code,\n      new_row.kri_value,\n      new_row.kri_status,\n      new_row.source,\n      new_row.evidence_id,\n      new_row.created_at,\n      -- Metadata fields\n      metadata_rec.name,\n      metadata_rec.description,\n      metadata_rec.formula,\n      metadata_rec.owner,\n      metadata_rec.data_provider,\n      metadata_rec.l1_risk_type,\n      metadata_rec.l2_risk_type,\n      metadata_rec.ras_metric,\n      metadata_rec.breach_type,\n      metadata_rec.limit_value,\n      metadata_rec.warning_line_value,\n      metadata_rec.negative_warning,\n      metadata_rec.negative_limit,\n      metadata_rec.reporting_frequency,\n      metadata_rec.is_calculated_kri;\nEND;\n$function$\n"
  }
]